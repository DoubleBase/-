# 缓存血崩问题及处理方案

## 什么是缓存血崩

缓存血崩指缓存由于某些原因（宕机，断网，光纤被挖等）整体失效了，导致大量请求落到数据库上，从而使得数据库崩溃，整个系统崩溃，发生灾难

## 缓存血崩场景

1. 流量激增：异常的流量，用户重试导致系统负载升高
2. 缓存刷新：假设A为client端，B为Server端，假设A系统请求都流向了B系统，请求超出了B系统的承载能力，就会造成B系统崩溃
3. 程序bug：代码循环调用的逻辑问题，资源未释放引起的内存泄漏等问题
4. 硬件故障：宕机，机房断电，光纤被挖断等
5. 数据库严重瓶颈：长事务、sql超时



## 缓存血崩的解决方案

缓存失效的几种情况：

1. 缓存服务器挂了
2. 高峰期缓存局部失效
3. 热点缓存失效

解决方案：

1. 避免缓存集中失效，不同的key设置不同的超时时间
2. 增加互斥锁，控制数据库请求，重建缓存
3. 提高缓存的HA，如：redis集群

血崩的整体解决方案：

（1）熔断模式：某个服务调用慢或者大量超时，则熔断该服务调用，对于后续的返回，快速释放资源。如果目标服务情况好转则恢复调用。

重点监控机器的性能指标：

- CPU
- Memory
- Mysql监控长事务
- sql超时
- 线程数

绝大多数应用服务器发生的血崩场景，都是来源于数据库端的性能瓶颈，从而先引起数据库端大量瓶颈，最终拖累应用服务器也发生血崩，最后就是大面积的血崩。

（2）隔离模式

对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。

（3）限流模式

可以用来预防，提前对各个类型的请求设置最高的QPS阈值，若高于阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成血崩效应。

### 熔断设计

（1）熔断请求判断算法

​	使用无锁循环队列计数，每个熔断器默认维护10个bucket，每1秒一个bucket，每个bucket记录请求的成功、失败、超时、拒绝的状态，默认错误超过50%且10秒内超过20个请求进行中断拦截。

（2）熔断恢复机制

​	对于被熔断的请求，每隔5s允许部分请求通过，若请求都是健康的（RT<250ms）则对请求健康恢复。

（3）熔断报警

​	对于熔断的请求打日志，异常请求超过某些设定则报警

### 隔离设计

（1）线程池隔离模式：

使用一个线程池来存储当前的请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求堆积入线程池队列。





（2）信号量隔离模式：







### 如何提前发现血崩

