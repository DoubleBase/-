### 服务治理

- 调用链路自动生成

  大型分布式系统，服务之间的调用链路依赖关系，把它呈现出来

- 服务访问压力以及时长统计

  统计各个接口和服务之间的调用次数和访问延时

  接口粒度：每个服务每个接口每天被调用的次数，TP50，TP90，TP99，三个档次请求延时是多少

  源头入口：一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求的延时TP50，TP90，TP99分别是多少

搞定这些，才知道当前系统的压力主要在哪里，如何来扩容和优化

- 其他的

  服务分层，调用链路失败监控，报警，服务鉴权

### 服务降级

通过服务降级功能，临时屏蔽某个出错的非关键服务，定义降级后的返回策略

`mock=force:return+null` 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。

还可以改为 `mock=fail:return+null` 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响

基于mock去操作，如果调用失败统一返回null

mock设置为true，在跟接口同一个路径下实现一个Mock类，命名规则是接口名称加Mock后缀，然后在Mock类里实现自己的降级逻辑

### 失败重试和超时重试

所谓失败重试，就是consumer调用provider要是失败了，比如抛异常了，此时应该是可以重试的，或者调用超时了也可以重试。

```xml
<dubbo:reference id="xxxx" interface="xx" check="true" async="false" retries="3" timeout="2000"/>
```

如果是超时了，timeout就会设置超时时间；如果是调用失败了自动就会重试指定的次数

retries，3次，设置retries，还一般是在读请求的时候，比如你要查询个数据，你可以设置个retries，如果第一次没读到，报错，重试指定的次数，尝试再次读取2次

