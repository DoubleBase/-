## 分布式服务接口幂等性

### 什么是幂等性

重复扣款问题

假如你有个服务提供一个接口，结果这服务部署在了5台机器上，接着有个接口就是付款接口。然后人家用户在前端上操作的时候，不知道为啥，总之就是一个订单不小心发起了两次支付请求，然后这俩请求分散在了这个服务部署的不同的机器上，好了，结果一个订单扣款扣两次，如下图所示：

![1565796490213](/image/分布式服务接口幂等性-重复扣款.png)

### 怎么保证

所谓幂等性，就是一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款，不能多插入一条数据，不将统计值多计1

主要有三点：

- 对于每个请求必须有一个唯一的标识。举个例子：订单支付请求，肯定得包含订单id，一个订单id最多支付一次
- 每次处理完请求后，必须有一个记录标识这个请求处理过了。比如，在数据库中记录个状态
- 每次接收请求，需要进行判断之前是否已经处理过。

建立唯一键，当有重复数据入库时，会抛出异常，我们回滚相应的事务即可

也可以将处理过的标识写入redis，下一次重复请求过来，先查询redis对应的key的状态是否已经处理过，已经处理过就不再处理请求



## 分布式接口调用顺序性

有这么一个场景：有一个业务会发起3个请求，需要保证3个请求按顺序去执行，如果请求落在不同的服务器上，那么执行顺序就乱了，导致业务功能不正常

最后系统设计的时候，不要有这种有严格顺序的场景，一旦引入顺序性保障，那么系统复杂度就会提高，带来效率降低

### 如何保证顺序性

- 首先使用dubbo的一致性hash负载均衡，将同一个业务的多个请求分发到同一台服务器上
- 接着，这台服务器可能因为多线程并发执行，需要将请求扔到同一个队列中去，强制排队，这样来保证顺序性

![1565799069154](/image/分布式服务接口顺序性.png)

引发的问题，比如某个订单的请求特别多，造成某台机器成热点，继而带来一连串的问题，所以还是建议不要设计这种强制顺序的方案



**方案二**：使用分布式锁，来保证请求的顺序性；不建议使用，并发性能低