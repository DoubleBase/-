- 主从复制原理
- 主从延迟产生的原因
- 主从复制数据丢失问题，以及半同步复制原理
- 并行复制的原理，多库并发重放relay日志，缓解主从延迟问题



## 为什么MySQL要读写分离

为什么：支持更高的并发量

如何实现：基于主从复制架构，搞一个主库，挂多个从库，往主库中写数据，主库会自动把数据同步同步到从库



## MySQL主从复制原理

主库将变更信息写入binlog日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 
SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 
SQL，这样就可以保证自己跟主库的数据是一样的

![](/image/mysql主从复制.png)

**从库同步主库数据的过程是串行化的**：从库读取binlog日志，写relay日志，应用日志变更到自己本地数据，这个过程是串行化的

主库上并行的操作，在从库上会串行执行，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到

还有个问题，如果主库宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了

- 产生所谓的主从延迟主要看主库的写并发

  主库的写并发达到1000/s，从库的延时会有几ms

  主库的写并发达到2000/s，从库的延时可能会有几十ms

  主库的写并发达到4000/s，6000/s，8000/s，主库都快死了，此时从库的延时可能达到几秒

半同步复制：解决数据丢失问题

并行复制：缓解主从同步延时问题

- 半同步复制

  semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了

- 并行复制：

  从库开启多个SQL线程，每个线程从relay log中读一个库的日志，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行

## 主从同步延时问题（重点）

是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 
2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新

用了mysql主从架构之后，可能会发现，刚写入库的数据结果没查到，结果就完蛋了。。。。

所以实际上你要考虑好应该在什么场景下来用这个mysql主从同步，建议是一般在读远远多于写，而且读的时候一般对数据时效性要求没那么高的时候，用mysql主从同步

通常来说，我们会对于那种写了之后立马就要保证可以查到的场景，采用**强制读主库**的方式，这样就可以保证你肯定的可以读到数据了吧。其实用一些数据库中间件是没问题的。

我们通过 MySQL 命令：

```sql
show status
```

查看 `Seconds_Behind_Master`，可以看到从库复制主库的数据落后了几 ms。

一般来说，如果主从延迟较为严重

1、分库，将一个主库拆分为4个主库，每个主库的写并发就500/s，此时主从延迟可以忽略不计

2、打开mysql支持的并行复制，多个库并行复制，如果说某个库的写入并发就是特别高，单库写并发达到了2000/s，并行复制还是没意义。28法则，很多时候比如说，就是少数的几个订单表，写入了2000/s，其他几十个表10/s。

3、重写代码，写代码的同学，要慎重，当时我们其实短期是让那个同学重写了一下代码，插入数据之后，直接就更新，不要查询

4、如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你这么搞导致读写分离的意义就丧失了

 

 